{"camera":{"position":[8.969207143592547,-0.7609176538910652,38.97402118768486],"target":[0,0,0],"nearClipping":0.1,"farClipping":1000,"projection":"Perspective","perspectiveFov":45,"orthographicFov":30},"model":{"mesh":"teapot","position":[0,-8,0],"rotationAxis":[1,0,0],"rotationAngle":-90,"scale":[1,1,1],"depthTest":"LESS","faceCulling":"","frontFace":"CCW","blendEnable":true,"blendOperation":"FUNC_ADD","srcColorBlendFactor":"SRC_ALPHA","dstColorBlendFactor":"ONE_MINUS_SRC_ALPHA","srcAlphaBlendFactor":"SRC_ALPHA","dstAlphaBlendFactor":"ONE_MINUS_SRC_ALPHA","textureFiltering":"LINEAR_MIPMAP_LINEAR","maxAnisotropy":"1"},"passes":{"Model":{"base":{"shaders":{"vertex":{"source":"#version 300 es\n\nin vec3 vertexPosition;\nin vec3 vertexNormal;\nin vec2 vertexTextureCoordinates;\n\nuniform mat4 mMatrix;\nuniform mat4 vMatrix;\nuniform mat4 pMatrix;\n\nuniform vec4 lightPosition;\nuniform bool lightInCamspace;\n\nout vec3 normal;\nout vec3 lightDirection;\n\nvoid main() {\n  vec4 vertexCamSpace = vMatrix * mMatrix * vec4(vertexPosition, 1.0);\n  gl_Position = pMatrix * vertexCamSpace;\n\n  normal = normalize(mat3(mMatrix) * vertexNormal);\n  \n  if (lightInCamspace) {\n    lightDirection = normalize(vec3(lightPosition - vertexCamSpace));\n  } else {\n    lightDirection = normalize(vec3(lightPosition));\n  }\n}"},"fragment":{"source":"#version 300 es\n\nprecision highp float;\nin vec3 normal;\nin vec3 lightDirection;\n\nout vec4 fragColor;\n\nvoid main() {\n  float intensity = dot(normal, lightDirection);\n\n  if (intensity > 0.98) {\n    fragColor = vec4(0.8, 0.8, 0.8, 1.0);\n  } else if (intensity > 0.5) {\n    fragColor = vec4(0.8, 0.4, 0.4, 1.0);\n  } else if (intensity > 0.25) {\n    fragColor = vec4(0.6, 0.2, 0.2, 1.0);\n  } else {\n    fragColor = vec4(0.1, 0.1, 0.1, 1.0);\n  }\n}"}},"uniforms":{"value":{"mMatrix":{"attachment":"Model Matrix"},"vMatrix":{"attachment":"View Matrix"},"pMatrix":{"attachment":"Projection Matrix"},"lightPosition":{"value":[0,0,0,1]},"lightInCamspace":{"value":[true]}}}}},"Quad":{"R2T":{"shaders":{"vertex":{"source":"#version 300 es\n\n// Vertex coordinates in object space for the render quad\nin vec3 vertexPosition;\n// Texture coordinate for this vertex and the render quad\nin vec2 vertexTextureCoordinates;\n\n// Texture coordinate needs to be passed on to the R2T fragment shader\nout vec2 fragmentTextureCoordinates;\n\n// Main program for each vertex of the render quad\nvoid main() {\n  gl_Position = vec4(vertexPosition, 1.0);\n  fragmentTextureCoordinates = vertexTextureCoordinates;\n}"},"fragment":{"source":"#version 300 es\n\nprecision highp float;\n\n// A texture sampling unit, which is bound to the render quad texture buffer\nuniform sampler2D textureRendered;\n\n// Texture coordinates coming from the vertex shader, interpolated through the rasterizer\nin vec2 fragmentTextureCoordinates;\nout vec4 fragColor;\n\n// Main program for each fragment of the render quad\nvoid main() {\n  fragColor = texture(textureRendered, fragmentTextureCoordinates.st);\n}"}},"uniforms":{"value":{"textureRendered":{"attachment":"Model/base Pass color"}}}}}},"output":{"image":"Quad/R2T Pass color"}}