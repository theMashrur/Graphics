{"camera":{"position":[0,0,40],"target":[0,0,0],"nearClipping":0.1,"farClipping":1000,"projection":"Perspective","perspectiveFov":45,"orthographicFov":30},"model":{"mesh":"teapot","position":[0,-8,0],"rotationAxis":[1,0,0],"rotationAngle":-90,"scale":[1,1,1],"depthTest":"LESS","faceCulling":"","frontFace":"CCW","blendEnable":true,"blendOperation":"FUNC_ADD","srcColorBlendFactor":"SRC_ALPHA","dstColorBlendFactor":"ONE_MINUS_SRC_ALPHA","srcAlphaBlendFactor":"SRC_ALPHA","dstAlphaBlendFactor":"ONE_MINUS_SRC_ALPHA","textureFiltering":"LINEAR_MIPMAP_LINEAR","maxAnisotropy":"1","showWireframe":false},"passes":{"Model":{"base":{"shaders":{"vertex":{"source":"#version 300 es\n\n// Vertex position in object space coordinates\nin vec3 vertexPosition;\n// Surface normal at the vertex in object space coordinates\nin vec3 vertexNormal;\n// Texture coordinates at that vertex\nin vec2 vertexTextureCoordinates;\n\nuniform vec4 lightPosition;\nuniform bool lightInCamspace;\n\n// Model matrix\nuniform mat4 mMatrix;\n// View matrix\nuniform mat4 vMatrix;\n// Projection matrix\nuniform mat4 pMatrix;\n\nout vec4 vertexCamSpace;\n\n// Output position in view space\nout vec3 vPosition;\n// Output normal in view space\nout vec3 vNormal;\n\n// Main program for each vertex\nvoid main() {\n  vec4 vertexCamSpace = vMatrix * mMatrix * vec4(vertexPosition, 1.0);\n  gl_Position = pMatrix * vertexCamSpace;\n  vPosition = vertexCamSpace.xyz;\n  //Vertex Normal in camera space\n  vNormal = (vMatrix * mMatrix * vec4(vertexNormal, 0.0)).xyz;\n}"},"fragment":{"source":"#version 300 es\n\n// For better performance less precision\nprecision highp float;\n\n// Per-vertex normal, from vertex shader\nin vec3 vNormal;\n// Per-vertex position, from vertex shader\nin vec3 vPosition;\n\n// Ambient color\nuniform vec4 ambientColor;\n// Diffuse color\nuniform vec4 diffuseColor;\n// Specular color\nuniform vec4 specularColor;\n// Shininess\nuniform float shininess;\n// Light position\nuniform vec4 lightPosition;\n// Light intensity\nuniform float lightIntensity;\n// Boolean indicating if the light is in camera space\nuniform bool lightInCamspace;\n\n// Per-Vertex Camera Space, from vertex shader\nin vec4 vertexCamSpace;\n\nout vec4 fragColor;\n\n// Main program for each fragment = pixel candidate\nvoid main() {\n  vec3 lightDirection;\n  if (!lightInCamspace) {\n    lightDirection = (lightPosition - vertexCamSpace).xyz;\n  } else {\n    vec3 vVertexPos = vec3(lightPosition * vec4(vPosition, 1.0));\n    lightDirection = vVertexPos - vPosition;\n  }\n  float d = length(lightDirection);\n  // Inverse Square Law\n  float lightInt = lightIntensity/(4.0 * 3.14 * d);\n  lightDirection = normalize(lightDirection);\n  vec3 normal = normalize(vNormal);\n  vec3 reflectDirection = reflect(-lightDirection, normal);\n  vec3 viewDirection = normalize(-vPosition);\n  \n  // Diffuse term of phong, making sure non-negative\n  float diffuseTerm = max(dot(lightDirection, normal), 0.0);\n  // Specular term of phong, making sure non-negative\n  float specularTerm = pow(max(dot(reflectDirection, viewDirection), 0.0), shininess);\n  \n  fragColor = lightIntensity * (ambientColor + diffuseTerm * diffuseColor + specularTerm * specularColor);\n}\n"}},"uniforms":{"value":{"lightPosition":{"value":[30,20,20,1]},"lightInCamspace":{"value":[false]},"mMatrix":{"attachment":"Model Matrix"},"vMatrix":{"attachment":"View Matrix"},"pMatrix":{"attachment":"Projection Matrix"},"ambientColor":{"value":[0.5,0,0,1]},"diffuseColor":{"value":[1,0,0,1]},"specularColor":{"value":[1,1,1,1]},"shininess":{"value":[10]},"lightIntensity":{"value":[1]}}}}},"Quad":{"R2T":{"shaders":{"vertex":{"source":"#version 300 es\n\n// Vertex coordinates in object space for the render quad\nin vec3 vertexPosition;\n// Texture coordinate for this vertex and the render quad\nin vec2 vertexTextureCoordinates;\n\n// Texture coordinate needs to be passed on to the R2T fragment shader\nout vec2 fragmentTextureCoordinates;\n\n// Main program for each vertex of the render quad\nvoid main() {\n  gl_Position = vec4(vertexPosition, 1.0);\n  fragmentTextureCoordinates = vertexTextureCoordinates;\n}"},"fragment":{"source":"#version 300 es\n\nprecision highp float;\n\n// A texture sampling unit, which is bound to the render quad texture buffer\nuniform sampler2D textureRendered;\n\n// Texture coordinates coming from the vertex shader, interpolated through the rasterizer\nin vec2 fragmentTextureCoordinates;\nout vec4 fragColor;\n\n// Main program for each fragment of the render quad\nvoid main() {\n  fragColor = texture(textureRendered, fragmentTextureCoordinates.st);\n}"}},"uniforms":{"value":{"textureRendered":{"attachment":"Model/base Pass color"}}}}}},"output":{"image":"Quad/R2T Pass color"}}