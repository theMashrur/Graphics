{"camera":{"position":[-1.8884794956223812,5.301975373502867,8.098509352813563],"target":[0,0,0],"nearClipping":0.1,"farClipping":1000,"projection":"Perspective","perspectiveFov":45,"orthographicFov":30},"model":{"mesh":"teapot","position":[0,-8,0],"rotationAxis":[1,0,0],"rotationAngle":-90,"scale":[1,1,1],"depthTest":"LESS","faceCulling":"","frontFace":"CCW","blendEnable":true,"blendOperation":"FUNC_ADD","srcColorBlendFactor":"SRC_ALPHA","dstColorBlendFactor":"ONE_MINUS_SRC_ALPHA","srcAlphaBlendFactor":"SRC_ALPHA","dstAlphaBlendFactor":"ONE_MINUS_SRC_ALPHA","textureFiltering":"LINEAR_MIPMAP_LINEAR","maxAnisotropy":"1"},"passes":{"Quad":{"R2T":{"shaders":{"vertex":{"source":"#version 300 es\n\n// Vertex coordinates in object space for the render quad\nin vec3 vertexPosition;\n// Texture coordinate for this vertex and the render quad\nin vec2 vertexTextureCoordinates;\n\nuniform float canvasWidth;\nuniform float canvasHeight;\n\nuniform vec3 cameraPosition;\nuniform mat3 cameraRotation;\n\nuniform bool isOrthographicProjection;\n\nuniform float orthographicFOV;\nuniform float perspectiveFOV;\n\nout vec3 origin;\nout vec3 dir;\n\n// Texture coordinate needs to be passed on to the R2T fragment shader\nout vec2 fragmentTextureCoordinates;\n\nvoid main() {\n\n\tfloat aspectRatio = canvasWidth/canvasHeight;\n\tvec3 origin_camSpace, dir_camSpace;\n\n\tif (isOrthographicProjection) {\n\t\torigin_camSpace = vec3(vertexPosition.x*orthographicFOV*aspectRatio, vertexPosition.y*orthographicFOV, 0);\n\t\tdir_camSpace = vec3(0, 0, -1);\n\t}\n\telse { // perspective projection\n\t\torigin_camSpace = vec3(0);\n\t\tdir_camSpace = vec3(vertexPosition.x*aspectRatio,vertexPosition.y,-1.0/tan(radians(perspectiveFOV)));\n\t}\n\torigin = cameraPosition + cameraRotation*origin_camSpace;\n\tdir = normalize(cameraRotation*dir_camSpace);\n\tgl_Position = vec4(vertexPosition, 1.0);\n    fragmentTextureCoordinates = vertexTextureCoordinates;\n}"},"fragment":{"source":"#version 300 es\n\nprecision highp float;\n\n// A texture sampling unit, which is bound to the render quad texture buffer\nuniform sampler2D textureRendered;\n\nuniform vec3 backgroundColor;\nuniform vec4 lightPosition;\nuniform float lightIntensity;\nuniform bool lightInCamspace;\n\nuniform float canvasWidth;\nuniform float canvasHeight;\n\nuniform vec3 cameraPosition;\nuniform mat3 cameraRotation;\n\nuniform bool isOrthographicProjection;\n\nuniform float orthographicFOV;\nuniform float perspectiveFOV;\n\n// Texture coordinates coming from the vertex shader, interpolated through the rasterizer\nin vec2 fragmentTextureCoordinates;\nin vec3 origin;\nin vec3 dir;\n\nout vec4 fragColor;\n\nstruct Sphere\n{\n\tvec3 centre;\n\tfloat radius;\n\tvec3 colour;\n};\n\nstruct Plane\n{\n\tvec3 point;\n\tvec3 normal;\n\tvec3 colour;\n};\n\nconst int max_depth = 3;\nconst float shadowRayBias = 0.0000001;\nconst float shininess = 10.0;\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 dir;\n};\n\nbool intersectSphere(Ray ray, Sphere sphere, out vec3 intersectionPoint, out vec3 normal)\n{\n    vec3 oc = ray.origin - sphere.centre;\n    float b = dot(oc, ray.dir);\n    float c = dot(oc, oc) - sphere.radius * sphere.radius;\n    float discriminant = b * b - c;\n    if (discriminant > 0.001)\n    {\n        float t = -b - sqrt(discriminant);\n        if (t > 0.0001)\n        {\n            intersectionPoint = ray.origin + ray.dir * t;\n            normal = normalize(intersectionPoint - sphere.centre);\n            return true;\n        }\n    }\n    return false;\n}\n\n// Function for intersetion with floor plane\nbool intersectPlane(Ray ray, Plane plane, out vec3 intersectionPoint, out vec3 normal)\n{\n    float denom = dot(ray.dir, plane.normal);\n    if (abs(denom) > 0.0001)\n    {\n        vec3 p0l0 = plane.point - ray.origin;\n        float t = dot(p0l0, plane.normal) / denom;\n        if (t >= 0.001)\n        {\n            intersectionPoint = ray.origin + ray.dir * t;\n            normal = plane.normal;\n            return true;\n        }\n    }\n    intersectionPoint = vec3(1000000, 1000000, 1000000);\n    normal = vec3(0, 0, 0);\n    return false;\n}\n\n\nfloat checkers(in vec2 p){\n    vec2 q = floor(p);\n    return mod(q.x + q.y, 2.0);\n}\n\n// Same as before, but implemented simple fog effect\nvoid main(){\n    fragColor = texture(textureRendered, fragmentTextureCoordinates.st);\n    int num_spheres = 6;\n    int num_planes = 1;\n    Plane plane;\n\n    // Define scene spheres\n    Sphere spheres[6];\n    spheres[0].centre = vec3(-2.0, 1.5, -3.5);\n    spheres[0].radius = 1.5;\n    spheres[0].colour = vec3(0.8,0.8,0.8);\n    spheres[1].centre = vec3(-0.5, 0.0, -2.0);\n    spheres[1].radius = 0.6;\n    spheres[1].colour = vec3(0.3,0.8,0.3);\n    spheres[2].centre = vec3(1.0, 0.7, -2.2);\n    spheres[2].radius = 0.8;\n    spheres[2].colour = vec3(0.3,0.8,0.8);\n    spheres[3].centre = vec3(0.7, -0.3, -1.2);\n    spheres[3].radius = 0.2;\n    spheres[3].colour = vec3(0.8,0.8,0.3);\n    spheres[4].centre = vec3(-0.7, -0.3, -1.2);\n    spheres[4].radius = 0.2;\n    spheres[4].colour = vec3(0.8,0.3,0.3);\n    spheres[5].centre = vec3(0.2, -0.2, -1.2);\n    spheres[5].radius = 0.3;\n    spheres[5].colour = vec3(0.8,0.3,0.8);\n\n    // Create floor plane\n    plane.point = vec3(0.0, -0.5, 0.0);\n    plane.normal = vec3(0.0, 1.0, 0.0);\n    plane.colour = vec3(0.8, 0.8, 0.8);\n\n    // Create ray\n    Ray ray;\n    ray.origin = origin;\n    ray.dir = normalize(dir);\n    float reflect_factor = 1.0;\n\n    // Start ray tracing up to max_depth\n    for (int i=0; i<max_depth; i++){\n        // Find closest intersection\n        float closestDistance = 1000000.0;\n        vec3 closestPoint;\n        vec3 closestNormal;\n        bool hit = false;\n        int closestObject = -1;\n\n        // Check for intersection with spheres\n        for (int j=0; j<num_spheres; j++){\n            vec3 intersectionPoint;\n            vec3 normal;\n            if (intersectSphere(ray, spheres[j], intersectionPoint, normal)){\n                float distance = length(intersectionPoint - ray.origin);\n                if (distance < closestDistance){\n                    closestDistance = distance;\n                    closestPoint = intersectionPoint;\n                    closestNormal = normal;\n                    closestNormal = normalize(closestNormal);\n                    hit = true;\n                    closestObject = j;\n                }\n            }\n        }\n\n        // Check for intersection with planes\n        vec3 intersectionPoint;\n        vec3 normal;\n        if (intersectPlane(ray, plane, intersectionPoint, normal)){\n            float distance = length(intersectionPoint - ray.origin);\n            if (distance < closestDistance){\n                closestDistance = distance;\n                closestPoint = intersectionPoint;\n                closestNormal = normal;\n                closestNormal = normalize(closestNormal);\n                hit = true;\n                closestObject = -1;\n            }\n        }\n\n        // If no intersection, accumulate background colour then exit\n        if (!hit){\n            fragColor = vec4(fragColor.rgb + reflect_factor * backgroundColor, 1.0);\n            return;\n        } else{ // Else calculate colour on ray hit\n            vec3 colour;\n            vec3 lightDir = normalize(lightPosition.xyz - closestPoint);\n            vec3 viewDir = normalize(cameraPosition - closestPoint);\n            vec3 reflectDir = normalize(reflect(-lightDir, closestNormal));\n            float specular = pow(max(dot(viewDir, reflectDir), 0.0), shininess);\n            float diffuse = max(dot(closestNormal, lightDir), 0.0);\n            if(closestObject >= 0){\n                vec3 col = spheres[closestObject].colour;\n                colour = spheres[closestObject].colour * (diffuse + specular) * lightIntensity;\n            } else {\n                float checkers = checkers(closestPoint.xz);\n                vec3 checkers_colour = checkers > 0.0 ? plane.colour : vec3(0.0, 0.0, 0.0);\n                colour = checkers_colour * (diffuse + specular) * lightIntensity;\n            }\n\n            // Shadow ray\n            Ray shadowRay;\n            shadowRay.origin = closestPoint + shadowRayBias * closestNormal;\n            shadowRay.dir = lightDir;\n            bool shadow = false;\n            for (int j=0; j<num_spheres; j++){\n                vec3 intersectionPoint;\n                vec3 normal;\n                if (intersectSphere(shadowRay, spheres[j], intersectionPoint, normal)){\n                    shadow = true;\n                }\n            }\n            if (shadow) {\n                fragColor = vec4(colour * 1.5, 1.0);\n                break;\n            }\n            // Cast secondary, reflected ray\n            ray.origin = closestPoint + shadowRayBias * closestNormal;\n            ray.dir = reflect(ray.dir, closestNormal);\n            ray.dir = normalize(ray.dir);\n            // Add fade with increasing distance to create fog effect\n            colour = mix(colour, 0.8 * vec3(1.0, 1.0, 1.0), 1.0 - exp2(-0.0011 * closestDistance * closestDistance));\n            fragColor = vec4(fragColor.rgb + reflect_factor * colour, 1.0);\n            // Geometrically decrement reflect factor: successive reflections should fade\n            reflect_factor = 0.3 * reflect_factor;\n        }\n    }\n\n}\n\n"}},"uniforms":{"value":{"canvasWidth":{"attachment":"Canvas Width"},"canvasHeight":{"attachment":"Canvas Height"},"cameraPosition":{"attachment":"Camera Position"},"cameraRotation":{"attachment":"Camera Rotation"},"isOrthographicProjection":{"attachment":"Orthographic Projection?"},"orthographicFOV":{"attachment":"Orthographic FOV"},"perspectiveFOV":{"attachment":"Perspective FOV"},"textureRendered":{"value":{"TEXTURE_2D":""}},"backgroundColor":{"value":[1,1,1]},"lightPosition":{"value":[6,4,3,1]},"lightIntensity":{"value":[1]},"lightInCamspace":{"value":[0]}}}}}},"output":{"image":"Quad/R2T Pass color"}}